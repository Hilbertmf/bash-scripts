{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"for loop": {
		"prefix": "for",
		"body": [
			"for(int ${1:i} = ${2:0}; ${1:i} < ${3:length}; ++${1:i}) {",
			"\t$0",
			"}"
		],
		"description": "for loop"
	},
	"reverse for loop": {
		"prefix": "rfor",
		"body": [
			"for(int ${1:i} = ${2:length} - 1; ${1:i} >= 0; --${1:i}) {",
			"\t$0",
			"}"
		],
		"description": "reverse for"
	},
	"for using iterator": {
		"prefix": "forvec",
		"body": [
			"for(auto ${1:it} = ${2:collection}.begin(); ${1:it} != ${2:collection}.end(); ++${1:it}) {",
			"\t$0",
			"}"
		],
		"description": "for using iterator"
	},
	"reverse for using iterator": {
		"prefix": "rforvec",
		"body": [
			"for(auto ${1:it} = ${2:collection}.rbegin(); ${1:it} != ${2:collection}.rend(); ++${1:it}) {",
			"\t$0",
			"}"
		],
		"description": "reverse for using iterator"
	},
	"foreach": {
		"prefix": "foreach",
		"body": [
			"for(auto &${1:item} : ${2:collection}) {",
			"\t$0",
			"}"
		],
		"description": "foreach loop"
	},
	"foreach const": {
		"prefix": "cforeach",
		"body": [
			"for(const auto &${1:item} : ${2:collection}) {",
			"\t$0",
			"}"
		],
		"description": "foreach const loop"
	},
	"while": {
		"prefix": ["while"],
		"body": ["while (${1:condition}) {",
			 "\t$0",
			  "}"
			],
		"description": "while loop"
	},
	"cin1": {
		"prefix": "cin1",
		"body": ["cin >> ${1:var};"],
		"description": "cin 1 variable"
	},
	"cin2": {
		"prefix": "cin2",
		"body": ["cin >> ${1:var1} >> ${2:var2};"],
		"description": "cin 2 variables"
	},
	"cin3": {
		"prefix": "cin3",
		"body": ["cin >> ${1:var1} >> ${2:var2} >> ${3:var3};"],
		"description": "cin 3 variables"
	},
	"cin4": {
		"prefix": "cin4",
		"body": ["cin >> ${1:var1} >> ${2:var2} >> ${3:var3} >> ${4:var4};"],
		"description": "cin 4 variables"
	},
	"cout": {
		"prefix": "out",
		"body": ["cout << ${1:var} << \"\\n\";"],
		"description": "cout"
	},
	"cout2": {
		"prefix": "out2",
		"body": ["cout << ${1:var1} << ${2:var2} << \"\\n\";"],
		"description": "cout 2 variables"
	},
	"class": {
		"prefix": "class",
		"body": ["class {1:MyClass}",
		"public:",
		"{3:int} {2:prop1}",
		"void method() {}",
		"};"
		],
		"description": "simple class"
	},
	"if": {
		"prefix": "if",
		"body": ["if(${1:condition}) {", "\t$0", "}"],
		"description": "if statement"
	},
	"elif": {
		"prefix": "elif",
		"body": ["else if(${1:condition}) {", "\t$0", "}"],
		"description": "else if statement"
	},
	"ifelse": {
		"prefix": "ifelse",
		"body": ["if(${1:condition}) {", "\t$0", "}", "else {", "\t", "}"],
		"description": "if else statements"
	},
	"else": {
		"prefix": "else",
		"body": ["else {", "\t$0", "}"],
		"description": "else statement"
	},
	"all in collection": {
		"prefix": "all",
		"body": ["${1:collection}.begin(), ${1:collection}.end()"],
		"description": "all in collection"
	},
	"reverse all in collection": {
		"prefix": "rall",
		"body": ["${1:collection}.rbegin(), ${1:collection}.rend()"],
		"description": "reverse all in collection"
	},
	"long long": {
		"prefix": "ll",
		"body": ["long long"],
		"description": "long long"
	},
	"list of int": {
		"prefix": "li",
		"body": ["list<${1:int}> ${2:myList}"],
		"description": "list of int"
	},
	"vector of int": {
		"prefix": "vi",
		"body": ["vector<${1:int}> ${2:vec}"],
		"description": "vector of int"
	},
	"vector of int with arguments": {
		"prefix": "viargs",
		"body": ["vector<${1:int}> ${2:vec}(${3:size}, ${4:defaultValue})"],
		"description": "vector of int"
	},
	"vector of long long": {
		"prefix": "vll",
		"body": ["vector<long long> ${2:vec}"],
		"description": "vector of long long"
	},
	"vector of string": {
		"prefix": "vs",
		"body": ["vector<string> ${2:vec}"],
		"description": "vector of string"
	},
	"pair of int": {
		"prefix": "pii",
		"body": ["pair<${1:int}, ${2:int}> ${2:myPair}"],
		"description": "pair of int"
	},
	"pair of long long": {
		"prefix": "pll",
		"body": ["pair<long long, long long> ${2:myPair}"],
		"description": "pair of long long"
	},
	"vector of pair of int": {
		"prefix": "vii",
		"body": ["vector<pair<${1:int}, ${2:int}>> ${2:vec}"],
		"description": "vector of pair"
	},
	"vector of pair of long long": {
		"prefix": "vpll",
		"body": ["vector<pair<long long, long long>> ${2:vec}"],
		"description": "vector of pair of long long"
	},
	"map of ints": {
		"prefix": "mpii",
		"body": ["map<${1:int}, ${2:int}> ${2:myMap}"],
		"description": "map of ints"
	},
	"multimap of ints": {
		"prefix": "mmpii",
		"body": ["multimap<${1:int}, set:int}> ${2:myMap}"],
		"description": "multimap of ints"
	},
	"set of int": {
		"prefix": "sti",
		"body": ["set<${1:int}> ${2:mySet}"],
		"description": "set of int"
	},
	"multiset of int": {
		"prefix": "mseti",
		"body": ["multiset<${1:int}> ${2:mySet}"],
		"description": "multiset of int"
	},
	"unordered map of ints": {
		"prefix": "umap",
		"body": ["unordered_map<${1:int}, ${2:int}> ${2:hashmap}"],
		"description": "unordered map of ints"
	},
	"unordered multimap of ints": {
		"prefix": "ummap",
		"body": ["unordered_multimap<${1:int}, ${2:int}> ${2:hashmap}"],
		"description": "unordered multimap of ints"
	},
	"unordered set of int": {
		"prefix": "uset",
		"body": ["unordered_set<${1:int}> ${2:hashset}"],
		"description": "unordered set of int"
	},
	"unordered multiset of int": {
		"prefix": "umset",
		"body": ["unordered_multiset<${1:int}> ${2:hashset}"],
		"description": "unordered multiset of int"
	},
	"unordered set of pair of int": {
		"prefix": "usetii",
		"body": ["struct pair_hash {",
		"inline std::size_t operator()(const std::pair<${1:int}, ${2:int}> & v) const {",
		"return v.first*31+v.second;",
		"}",
		"",
		"unordered_set<pair<${1:int}, ${2:int}>, pair_hash> ${3:hashset}"],
		"description": "unordered set of pair of int"
	},
	"unordered multiset of pair of int": {
		"prefix": "musetii",
		"body": ["struct pair_hash {",
		"inline std::size_t operator()(const std::pair<${1:int}, ${2:int}> & v) const {",
		"return v.first*31+v.second;",
		"}",
		"",
		"unordered_multiset<pair<${1:int}, ${2:int}>, pair_hash> ${3:hashset}"],
		"description": "unordered multiset of int"
	},
	"push back": {
		"prefix": "pbk",
		"body": ["push_back(${1:var1})"],
		"description": "push back"
	},
	"ordered set": {
		"prefix": "ordset",
		"body": ["typedef tree<${1:int}, // key type",
		"${2:null_type}, // mapped-policy",
		"less<${3:int}>, // key comparison function",
		"rb_tree_tag, // underlying data structure",
		"tree_order_statistics_node_update>",
		"ordered_set;",
		"// use order_of_key and find_by_order methods",
		],
		"description": "ordered set"
	},
	"ordered multiset": {
		"prefix": "ordmset",
		"body": ["typedef tree<${1:int}, // key type",
		"${2:null_type}, // mapped-policy",
		"less_equal<${3:int}>, // key comparison function",
		"rb_tree_tag, // underlying data structure",
		"tree_order_statistics_node_update>",
		"ordered_set;",
		"// use order_of_key and find_by_order methods",
		"// using less_equal exchanges upper and lower bounds",
		"// use upper bound to erase elements",
		"// order_of_key refers to the first occurence of key"
		],
		"description": "ordered multiset"
	},
	"ordered map": {
		"prefix": "ordmap",
		"body": ["typedef tree<${1:int}, // key type",
		"${2:int}, // mapped-policy",
		"less<${3:int}>, // key comparison function",
		"rb_tree_tag, // underlying data structure",
		"tree_order_statistics_node_update>",
		"ordered_map;",
		"// use order_of_key and find_by_order methods"
		],
		"description": "ordered map"
	},
	"ordered multimap": {
		"prefix": "ordmultimap",
		"body": ["typedef tree<${1:int}, // key type",
		"${2:int}, // mapped-policy",
		"less_equal<${3:int}>, // key comparison function",
		"rb_tree_tag, // underlying data structure",
		"tree_order_statistics_node_update>",
		"ordered_map;",
		"// use order_of_key and find_by_order methods",
		"// using less_equal exchanges upper and lower bounds",
		"// use upper bound to erase elements",
		"// order_of_key refers to the first occurence of key"
		],
		"description": "ordered multimap"
	}
}
